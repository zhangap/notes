# JavaScript语言精髓和编程实战

程序设计语言总是有三种基本性质：语法、语义与语用。

1. 语法：是指我们表达内容的形式。

2. 语义：是指我们表达内容的逻辑含义。语义有以下基本特质：
   - 必须是一个含义
   - 该含义必须能够以某种基本的逻辑形式予以阐述。
   - 该逻辑所表达的含义可以为语言的接受者所知。（非基本特质）
   
3. JavaScript的应用环境，主要包含了宿主环境与运行期环境构成。

   ![](../images/读书笔记/javascript语言精髓与编程实践/应用环境.png)

   ​	运行期环境特指由引擎创建的初始环境：

   - ​	一个对宿主的约定
   - 一个引擎内核
   - 一组对象和API
   - 一些其他的规范

4. 语法关键字是对语义逻辑绑定的结果，是对作用域的限定；变量是对位置性质的绑定结果，则是对变量生存周期的限定。

5. 识别语法错误与运行错误：一般来说，JavaScript引擎会在代码装入时先进行语法分析，如果语法分析通不过，整个脚本代码块都不执行；当语法分析通过时，脚本代码才会执行。若在执行过程中出错，那么在同一代码上下文中、出错点之后的代码将不再执行。

6. 基于类型系统的运算中：

   - 一般表达式运算的结果总是值
   - 函数、方法调用的结果可以返回值类型，也可以返回引用类型。
   - 值与引用、值与值之间即使相等（==），也不一定严格相等（===）。
   - 两个引用之间如果相等（==），则一定严格相等（===）。

7. let声明变量和var声明变量的区别：

   1. 作用域：var声明的变量，其作用域为当前函数、模块或全局；let声明变量，其作用域总是在当前代码块，例如语句块。
   2. 重复申明：在同一个代码块中，var可以多次声明同一个变量名，在语法分析中和声明一次没有区别；let只能声明一次，重复声明会导致语法错误。
   3. 对变量的使用：var声明的变量，可以使用在前，其值为undefined；let必须是先声明后使用，声明之前使用会触发异常，这也会导致typeof成为一个不安全的运算。
   4. 全局声明：使用var在全局声明一个变量，相当于在全局对象global（window）上声明了一个属性，进而使得所有代码都能将这些声明作为全局变量来访问；let声明全局变量，始终遵从“块级作用域”规则，因此即使出现在全局代码块中，它们也只是声明为“全局作用域”中的标识符，而不是作为global对象上的属性。如下：

   ![](../images/读书笔记/javascript语言精髓与编程实践/let和var声明的区别.png)

8. 模板字面量本质来说是一个字面量的引用-该字面量在JavaScript内部表达为一个对象（array-like-object）或数组。

   ![](../images/读书笔记/javascript语言精髓与编程实践/模板字面量.png)

9. 逻辑或和逻辑与既不改变操作数的操作类型，也不强制运算结果的数据类型。除此之外，还有以下两条特性：

   - 运算符会将操作数隐士转换为布尔值，以进行布尔运算。
   - 运算过程（与普通布尔运算一样）是支持布尔短路的。

10. 将字符串作为类似数组的对象，可以用下标去访问，但是不能通过该运算去修改该字符串的值。

11. 从ES6开始，字符串又被添加了Symbol.iterator属性，它可以作为可迭代对象处理，例如，接受数组展开以及yield*等运算（以及for...of语句）。

12. JavaScript总是尽量用数字值比较来实现等值检测，这主要是因为JavaScript内部的数据存储格式适合这一操作。同样的原因（出于内部存储格式的限制），字符串检测通常会存在非常大的开销。

13. 赋值运算对值类型来说是复制数据，而对于引用类型来说，则只是复制一个地址。这里存在两个特例：

    1. 值类型的字符串是一个大的，不确定长度的连续数据块，这导致复制数据的开销很大，所以在JS中将字符串的赋值也变成了复制地址，该字符串（连续数据块起始处）的地址引用。由此引入了三条字符串的限制：

       - 不能直接修改字符串中的字符。
       - 字符串连接运算必然导致写复制，这将产生新的字符串。
       - 不能改变字符串的长短，例如，修改length属性是无意义的。

    2. 在ES6之后的解构赋值中，赋值运算符的语义并不只有“复制地址/复制引用”，还包括“解析数组或对象的成员”这一行为。在具体到向赋值模板中复制这些成员的值（或引用）时，仍然是“赋值的效果是修改存储单元的值”。

       ![](../images/读书笔记/javascript语言精髓与编程实践/解构赋值中的值复制.png)

14. new functionReference(), 在语法中，functionReference后面的括号并不是函数调用运算符，而只是new运算符语法的参数传入表（这是因为，在这一语法中决定或启动函数调用的是new运算符而非这对括号。不过在少数情况下，new运算符会被用作隐士的函数调用）。

15. typeof是运算符，而不是语法关键字。但是在ES6之后，一个标识符不再是简单的有或者是没有，而typeof也就不总是安全的。因此与使用var变量不同的是，当typeof操作一个“使用let/const声明但未绑定值”的名字时，将就抛出一个异常。

    ![](../images/读书笔记/javascript语言精髓与编程实践/typeof声明.png)

16. 模块加载方式：

    - 简单装载：module.js中没有提供任何export语句，此时可用(只能使用) import 'module.js'。如果使用import xxx from 'module.js',会报错。
    - 命名导入：import defaultExport from 'moduleName'; import {importList} from 'moduleName'。
    - 命名空间导入： import * as  someNameSpace from 'moduleName'。

17. 装载模块意味着模块中的顶层代码会被执行一次，由于引擎的模块装载系统会静态扫描全部模块并确定装载的次序，所以事实上模块名“import”语句中出现和被依赖的次序也就成了那些顶层代码得以执行的次序。

18. 所有模块的顶层代码都是顺序的、串行的执行。

19. 有7种语法在严格模式中被禁用，但是在旧的ECMAScript版本中，它们是合法的。

    - 在对象字面量声明中存在相同的属性名。
    - 在函数声明中，参数表中带有相同的参数名。
    - 不能声明或重写eval和arguments这两个标识符。同时，这两个标识符也不能是用delete进行删除。
    - 用0前缀声明的8进制字面量。
    - 用delete删除显示声明的标识符、名称或具名函数。
    - 在代码中使用一些扩展的保留字，这些保留字包括implements、interface、let、packaage、private、protected、public、static、以及yield等。
    - 在代码中包含with语句。
    
20. 加号的二义性

    1. 表示字符串连接。（如果表达式中有字符串，则优先按字符串连接进行计算）
    2. 数字取正值的一元运算符
    3. 表达式的求和。

21. 括号的二义性

    1. 函数声明中的虚拟参数表。
    2. 传值参数表，并不表达函数调用的含义（只出现在new 关键字的使用中）。
    3. 可以在with、for、if、while和do...while等语句，以及catch（）等子句中用来作为限定表达式的词法元素。
    4. 可用于强制表达式运算。
    5. 作为函数、方法调用运算符。
    6. **函数调用过程中的括号“（）”是运算符。也因此得出推论，当“（）”作为运算符时，它只作用于表达式运算，而不可能作用于语句。**

22. 冒号的二义性

    1. 声明对象字面量的成员和声明标签。
    2. 在switch语句中声明一个分支。
    3. 在三元表达式中，表示条件为false时的表达式分支。

23. 大括号的二义性（所有的作用都是作为语法和词法符号来是用的）

    1. 复合语句（标签后的复合语句、条件分支后的复合语句）。
    2. 声明对象字面量
    3. 函数的声明
    4. 结构化异常。 try{}catch(){}finally{}
    5. 模板中的变量引用
    6. 解构赋值

24. Javascript中为面向对象设计的语法元素

    | 类型       | 语法元素    | 含义                       |
    | ---------- | ----------- | -------------------------- |
    | 字面量声明 | ｛...｝     | （一般）对象               |
    |            | [...]       | 数组对象                   |
    |            | /.../       | 正则表达式对象             |
    | 类的声明   | class       | 声明类                     |
    |            | constructor | 声明构造方法               |
    |            | get         | 声明属性取值方法           |
    |            | set         | 声明属性设置方法           |
    |            | methodName  | 声明方法                   |
    | 运算符     | new         | 创建指定类的对象实例       |
    |            | instanceof  | 检查变量是否是指定类的实例 |
    |            | delete      | 删除实例属性               |
    |            | .           | 存取对象成员（属性、方法） |
    |            | []          | 存取对象成员（属性、方法） |
    |            | in          | 检查对象属性               |
    | 语句       | for...in    | 列举对象成员名             |
    |            | for...of    | 列举数组成员值             |
    |            | with        | 设定语句默认对象           |
    | 其他       | super       | 类声明中引用父类           |
    |            | new.target  | 构造器函数中引用构造器自身 |
    |            | this        | 在上下文中指向当前对象实例 |
    
25. 每个对象都有一个propertyIsEnumerable方法。此方法可以确定对象中指定的属性是否可以被for...in循环枚举，但是通过原型继承的属性除外。如果对象没有指定属性，则此方法返回false。

26. for...of可以列举带所有迭代器的对象（可迭代对象），而不论它们是否是集合或者是数组。如字符串。

27. JS是用in运算来检查对象是否具有某个成员（包括显示的和隐士的，也包括符号作为键名的属性）。

28. delete可以删除全局变量，但是用var/const/let声明的变量是不能被删除的。

29.  JavaScript确保即使用户代码在多个地方调用Symbol.for(),也有且仅有第一次调用时会创建（并返回）符号，而此后的调用都将直接返回该符号。这种内建机制保证了这些符号的全局唯一。

30. 子类必须具有父类的特性。这也是JS中不能用delete删除从父类继承来的成员的原因。尽管这看起来是“自由属性表”带来的特性，但是他确保了在重写成员、改变它的实现等的同时，在界面上保持与父类的必然一致性。

31. JavaScript原型继承的实质便是对原型修改“效果的传递”，它基于以下两个事实。

    - 原型：原型是一个对象。
    - 原型链：在访问属性时，如果子类对象没有该属性，则将访问其原型的属性表。
    
32. 在声明中使用了extends关键字，所以在构造器中必须调用super()。

33. 函数中所关联的this引用，有三个规则来决定：

    - 使用当前上下文中的this或函数已绑定的this。
    - 在使用属性存取运算符（包括.和[]）时将左操作数作为this传入。
    - 使用Function.call, Function.apply,Functoin.bind或Reflex.apply等，将指定参数传入以用来作为this引用。

34. 当一个函数在调用时得到的this值是undefined或null时，那么如果函数工作在严格模式下，则仍然使用undefined或null值作为this；否则将以全局对象作为this的值。

35. 箭头函数的特性：

    1. 相较于函数表达式，箭头函数具有更简洁的语法。
    2. 没有单独的this：箭头函数没有自己的this，只会根据从自己的作用域链的上一层继承this。
    3. 使用apply、call和bind并不能改变this指向。通常第一个参数会忽略。
    4. 不绑定arguments对象，在大多数情况下，使用剩余参数是更好的选择。
    5. 不能用作构造器，和new一起用会抛出错误。
    6. 没有prototype属性。
    7. yield关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用做函数生成器。
    8. 箭头函数内部不能直接返回对象字面量，需要用括号括起来。
    9. 箭头函数在参数和箭头之间不能换行。

36. 类抄写的几个问题：

    1. 所有的方法都写在构造函数中，每次构造的实例之间，他们的方法并不是同一个函数，这意味着更多的内存开销。
    2. 类抄写的所有属性都是在实例的自有属性表中，访问任何成员都不必回溯到原型链，因而效率更高。
    3. 并不维护原型继承链。所以不能用instanceof运算来检测继承关系。
    4. 总之，类抄写并没有利用原型继承的任何特性。

37. 原型继承的缺陷：

    1. 在维护构造器引用和外部原型链之间无法平衡。
    2. 没有提供调用父类方法的机制。
    3. 继承层次中的邻近成员访问更快，而试图访问一个不存在的成员耗时最久。

38. 类继承倾向于在基类中实现更基础、更稳定和更通用的对象性质、以减轻在子类和最终实例上实现逻辑的负担。

39. 常见的错误类型：

    ![](../images/读书笔记/javascript语言精髓与编程实践/原生的和用户自定义的错误类型.png)

40. JavaScript的数组是异质、交错和稀疏的，可以存在不连续的下标（元素为undefined的空洞）以及保存任意类型的元素。

41. 数组由于存储的不连续性，以及元素的不一致性，因而有着巨大的性能问题，所以JavaScript也提供了类型化数组（TypedArray）来高效处理地址连续、成员结构化的集合。其中copyWithin、fill、set、sort、reverse五个方法可以影响元素的值。

42. 代理机制并不改变原始对象自己的操作，只能响应“在代理对象上发生的”行为。

    ```javascript
    var obj = {
        value: 100
    };
    var p = new Proxy(obj, {
        get(target,key) {
            console.log('代理get方法被执行');
            return target[key] * 2;
        }
    });
    // 返回100
    console.log(obj.value);
    // 返回200
    console.log(p.value);
    ```

43. 属性按照它的描述符的不同，可以分为以下两类：

    - 数据属性
    - 存取属性：用get/set定义的属性。

44. 属性的**性质**是不可继承的。

45. 在严格模式中向未声明的变量赋值是被禁止的。

46. 所有模块的顶层代码都是顺序的、串行地执行的。顶层的文件是由引擎装入并被称为主模块，它是逻辑上所有代码的入口。
