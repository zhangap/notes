#### 三次握手

三次握手是为了确认客户端和服务端双方的发送和接收能力是否正常。

##### 步骤

1.  握手之前：

   客户端为closed状态，服务端为listen状态；

2. 第一次握手：

   客户端往服务端发送一个包，包含SYN报文和初始序列号seq：SYN=1, seq=x；

   客户端为SYN_SENT状态;

   服务端得出结论：客户端发送能力、服务端接收能力正常； 

3. 第二次握手：

   服务端往客户端发送一个包，包含SYN报文、ACK报文、初始序列号seq和确认号ack：

   SYN=1, ACK=1, seq=y, ack=x+1；

   服务端为SYN_RCVD状态；

   客户端得出结论：客户端发送能力、接收能力正常，服务端发送能力、接收能力正常。✅

4. 第三次握手：

   客户端往服务端发送了一个包，包含ACK报文、序号seq和确认号ack：ACK=1, seq=x+1, ack=y+1。

   客户端为ESTABILISHED状态，服务端收到客户端ACK报文之后，也变为ESTABILISHED状态，双方建立连接。

   服务端得出结论：客户端接收能力、服务端发送能力正常。✅



##### 为什么要三次握手而不是两次

接下来是一段绕口令：两次握手完成，客户端知道客户端的接收、发送能力正常，服务端接收、发送能力正常，但是服务端只知道客户端发送能力和服务端接收能力正常，并不知道服务端的发送能力以及客户端接收能力是否正常。



##### 三次握手可以携带参数吗

第三次是可以的。前两次不行，一是避免恶意攻击服务器，二是前两次携带参数也没有意义。

第三次的时候，客户端是知道客户端和服务端接收和发送能力都是正常的，因此携带数据也是没问题的。



##### SYN攻击

客户端在短时间创造很多不存在的ip，向服务端发送SYN包，服务端回复确认包等待客户端的回应。

由于源地址不存在，服务端就不断重发确认包直到超时，导致网络堵塞乃至系统瘫痪。

防御方式：缩短超时时间、增大半连接数，过滤网关、SYN cookie技术。



#### 四次挥手

四次挥手用于终止一个连接。

##### 步骤

1. 挥手之前：

   客户端和服务端都处于ESTABILISHED状态；

2. 第一次挥手：

   客户端想终止连接了，

   客户端往服务端发送一个包，包含FIN连接释放报文、序号seq：FIN=1, seq=u；

   客户端主动关闭TCP连接，进入FIN_WAIT1状态；

3. 第二次挥手：

   服务端知道客户端想终止连接了，但是服务端还不想终止，

   服务端往服务端发送一个包，包含ACK报文、序号seq和确认号ack：ACK=1, seq=v,ack=u+1;

   服务端为CLOSE_WAIT状态，客户端收到服务端报文进入FIN_WAIT2状态；

4. 第三次挥手：

   服务端想终止连接了，

   服务端往客服端发送一个包，包含FIN连接释放报文、ACK报文、序号seq和确认号ack:

   FIN=1, ACK=1, seq=w, ack=u+1；

   服务端进入LAST_ACK状态，等待客户端的确认；

5. 第四次挥手：

   客户端知道服务端也想终止连接了，

   客户端往服务端发送一个包，包含ACK报文、序号seq和确认号ack:

   ACK=1, seq=u+1, ack=w+1。

   此时客户端状态为TIME_WAIT状态，服务端收到报文后进入CLOSED状态,

   客户端要等待2MSL时间后，进入CLOSED状态。



##### 为什么需要四次挥手

当服务端接收到客户端发送的FIN连接释放报文时，服务端的报文很可能还没有发送完，只能先回复一个ACK报文，表明自己知道了客户端要关闭TCP连接的想法了。服务端等所有的报文发送完了，才能发送FIN连接释放报文。因此断开连接需要比连接时多一次。



##### 客户端在发送最后一个包之后，为什么要等2MSL

MSL是最长报文段寿命，是任何报文在网络上存在的时间。

1. 给丢包一次机会；
2. 确保下一次连接中不会出现这次连接请求报文段。



参考链接：

1. https://juejin.cn/post/6844903958624878606
1. https://segmentfault.com/a/1190000019292140

